
# middleware
    import "github.com/goadesign/middleware"




## Constants
``` go
const ReqIDKey middlewareKey = 1
```
ReqIDKey is the context key used by the RequestID middleware to store the request ID value.

``` go
const RequestIDHeader = "X-Request-Id"
```
RequestIDHeader is the name of the header used to transmit the request ID.



## func LogRequest
``` go
func LogRequest() goa.Middleware
```
LogRequest creates a request logger middleware.
This middleware is aware of the RequestID middleware and if registered after it leverages the
request ID for logging.


## func LogResponse
``` go
func LogResponse() goa.Middleware
```
LogResponse creates a response logger middleware.
Only Logs the raw response data without accumulating any statistics.


## func Recover
``` go
func Recover() goa.Middleware
```
Recover is a middleware that recovers panics and returns an internal error response.


## func RequestID
``` go
func RequestID() goa.Middleware
```
RequestID is a middleware that injects a request ID into the context of each request.
Retrieve it using ctx.Value(ReqIDKey). If the incoming request has a RequestIDHeader header then
that value is used else a random value is generated.


## func RequireHeader
``` go
func RequireHeader(
    pathPattern *regexp.Regexp,
    requiredHeaderName string,
    requiredHeaderValue *regexp.Regexp,
    failureStatus int) goa.Middleware
```
RequireHeader requires a request header to match a value pattern. If the
header is missing or does not match then the failureStatus is the response
(e.g. http.StatusUnauthorized). If pathPattern is nil then any path is
included. If requiredHeaderValue is nil then any value is accepted so long as
the header is non-empty.


## func Timeout
``` go
func Timeout(timeout time.Duration) goa.Middleware
```
Timeout sets a global timeout for all controller actions.
The timeout notification is made through the context, it is the responsability of the request
handler to handle it. For example:


	func (ctrl *Controller) DoLongRunningAction(ctx *DoLongRunningActionContext) error {
		action := NewLongRunning()      // setup long running action
		c := make(chan error, 1)        // create return channel
		go func() { c <- action.Run() } // Launch long running action goroutine
		select {
		case <- ctx.Done():             // timeout triggered
			action.Cancel()         // cancel long running action
			<-c                     // wait for Run to return.
			return ctx.Err()        // retrieve cancel reason
		case err := <-c:   		// action finished on time
			return err  		// forward its return value
		}
	}

Package golang.org/x/net/context/ctxhttp contains an implementation of an HTTP client which is
context-aware:


	func (ctrl *Controller) HttpAction(ctx *HttpActionContext) error {
		req, err := http.NewRequest("GET", "<a href="http://iamaslowservice.com">http://iamaslowservice.com</a>", nil)
		// ...
		resp, err := ctxhttp.Do(ctx, nil, req) // returns if timeout triggers
		// ...
	}

Controller actions can check if a timeout is set by calling the context Deadline method.









- - -
Generated by [godoc2md](http://godoc.org/github.com/davecheney/godoc2md)