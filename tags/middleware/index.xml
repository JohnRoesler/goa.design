<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Middleware on goa</title>
    <link>http://goa.design/tags/middleware/</link>
    <description>Recent content in Middleware on goa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 Jan 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://goa.design/tags/middleware/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>middleware</title>
      <link>http://goa.design/godoc/middleware/</link>
      <pubDate>Sun, 31 Jan 2016 00:00:00 +0000</pubDate>
      
      <guid>http://goa.design/godoc/middleware/</guid>
      <description>

&lt;h1 id=&#34;middleware:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;middleware&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;import &amp;quot;github.com/goadesign/middleware&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;constants:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;Constants&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const ReqIDKey middlewareKey = 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ReqIDKey is the context key used by the RequestID middleware to store the request ID value.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const RequestIDHeader = &amp;quot;X-Request-Id&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RequestIDHeader is the name of the header used to transmit the request ID.&lt;/p&gt;

&lt;h2 id=&#34;func-logrequest:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func LogRequest&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func LogRequest() goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LogRequest creates a request logger middleware.
This middleware is aware of the RequestID middleware and if registered after it leverages the
request ID for logging.&lt;/p&gt;

&lt;h2 id=&#34;func-logresponse:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func LogResponse&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func LogResponse() goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;LogResponse creates a response logger middleware.
Only Logs the raw response data without accumulating any statistics.&lt;/p&gt;

&lt;h2 id=&#34;func-recover:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func Recover&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Recover() goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Recover is a middleware that recovers panics and returns an internal error response.&lt;/p&gt;

&lt;h2 id=&#34;func-requestid:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func RequestID&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func RequestID() goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RequestID is a middleware that injects a request ID into the context of each request.
Retrieve it using ctx.Value(ReqIDKey). If the incoming request has a RequestIDHeader header then
that value is used else a random value is generated.&lt;/p&gt;

&lt;h2 id=&#34;func-requireheader:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func RequireHeader&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func RequireHeader(
    pathPattern *regexp.Regexp,
    requiredHeaderName string,
    requiredHeaderValue *regexp.Regexp,
    failureStatus int) goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RequireHeader requires a request header to match a value pattern. If the
header is missing or does not match then the failureStatus is the response
(e.g. http.StatusUnauthorized). If pathPattern is nil then any path is
included. If requiredHeaderValue is nil then any value is accepted so long as
the header is non-empty.&lt;/p&gt;

&lt;h2 id=&#34;func-timeout:37ab2f15ff048f67959bcac0a6032f32&#34;&gt;func Timeout&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Timeout(timeout time.Duration) goa.Middleware
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Timeout sets a global timeout for all controller actions.
The timeout notification is made through the context, it is the responsability of the request
handler to handle it. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (ctrl *Controller) DoLongRunningAction(ctx *DoLongRunningActionContext) error {
    action := NewLongRunning()      // setup long running action
    c := make(chan error, 1)        // create return channel
    go func() { c &amp;lt;- action.Run() } // Launch long running action goroutine
    select {
    case &amp;lt;- ctx.Done():             // timeout triggered
        action.Cancel()         // cancel long running action
        &amp;lt;-c                     // wait for Run to return.
        return ctx.Err()        // retrieve cancel reason
    case err := &amp;lt;-c:        // action finished on time
        return err          // forward its return value
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Package golang.org/x/net/context/ctxhttp contains an implementation of an HTTP client which is
context-aware:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func (ctrl *Controller) HttpAction(ctx *HttpActionContext) error {
    req, err := http.NewRequest(&amp;quot;GET&amp;quot;, &amp;quot;&amp;lt;a href=&amp;quot;http://iamaslowservice.com&amp;quot;&amp;gt;http://iamaslowservice.com&amp;lt;/a&amp;gt;&amp;quot;, nil)
    // ...
    resp, err := ctxhttp.Do(ctx, nil, req) // returns if timeout triggers
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Controller actions can check if a timeout is set by calling the context Deadline method.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Generated by &lt;a href=&#34;http://godoc.org/github.com/davecheney/godoc2md&#34;&gt;godoc2md&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>